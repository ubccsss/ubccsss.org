---
# The title of the post
title: "110 Study Guide"
# Tags that apply to the post
tags: []
categories: []
# Name of the author (you)
author: William Gervasio
# Images associated to this post. Used for banner.
images:
  - /files/TODO-banner.png
---

![](/files/TODO-banner.png)

# UBC CPSC 110 Study Outline

Whether you are taking CPSC 110 as an elective or as a prospective Computer Science student, 110 can be a difficult course that is quite different from your average math or chemistry class. So to help you out, we have compiled a general guide and some notes of each unit to help you along.

|Outline|
|---|
|Main Ideas|
|General Habits on Problems|
|General Course Habits|
|High Level Summary|
|Unit Notes|
|Sample Study Schedule|

<br>

|Unit Breakdown|
|---|
|1a: Beginning Student Language|
|1b: How to Design Functions|
|2: How to Design Data|
|3a: How to Design Worlds|
|3b: Compound Data|
|4a: Self-Reference|
|4b: Reference|
|5a: Naturals|
|5b: Helpers|
|6a: Binary Search Trees|
|6b: Mutual Reference|
|7a: Two One-Of Types|
|7b: Local|
|8: Abstraction|
|9a: Generative Recursion|
|9b: Search|
|10: Accumulators|
|11: Graphs|








## Main Ideas

Generally, you want to make sure to not fall behind in the course; this can be true for many cases, but especially for 110. You will have a variety of pre-lecture videos and review work that will be necessary to grasp the lecture content more easily and keep up with the fast pace of the course. 110 follows a flipped classroom format which will mean you often do a lot of learning before coming to lecture. 
<br>
> They expect me to teach myself.

 is a rather accurate comment; and often that is something you will need to do in Computer Science fields.
<br>
110 is titled “Systematic Program Design,” which summarizes the main course content and assessment style. You will often focus on following “recipes” that consist of steps that you need to follow closely. Now it may get quite frustrating in the first few units when most questions are simpler or easy, but it pays off a lot more when you reach the last few units and work on very difficult questions.

<br>

With the “recipes” a major selling point is that you think less to get most of the solution. With some memorization from practice, you can put down most of the code that solves a complex maze using these “recipes”:
<br>

Whether on a problem set, lab, or exam, FOLLOW THE RECIPE to the dot. And if you get stuck, you should be able to know which step of that recipe you are working on. Putting down most of the recipe will often be better than putting nothing for a question.
 
<br>
PS. Please read through the syllabus on the website before asking anything about grading practices or schedules or expectations on content, odds are the answer will be on there. 

## General Habits on Problems

1. Follow the style rules. Spam `ctrl+i` or `cmd+i` (on mac) to make sure your code is always indented properly. Make sure your purpose is always one line long. Make sure to include the cross-produce table, accumulator invariants, and genrec arguments for the relevant questions.
2. Follow the recipe in order. If you consistently solve these problems with the same steps, it becomes less of a problem that you 'forgot to include something’ in your answers. 
3. Copy-paste the template of a function design problem before working on it. Often in the later units, you will have a template available for data to work on. If you copy-paste the template and focus on filling in the dots, you will often have an easier job on matching the expected solutions.
4. Draw complex issues on paper and make use of great examples when solving issues. Sometimes we just need a visualization of something or some simple examples to get started. Often when you are blocked on an issue, that picture or example can indicate something you are missing.
5. **Run your code often.** Your code may not pass all of your tests, but make sure that it can at least RUN. It is comforting to know it is not broken completely, and you can experiment with that code to get to the final solution you are looking for.

## General Course Habits

Here is a list of habits we would probably recommend when keeping up with course content:
1. Keep up to date with the pre-reading videos; maybe even watch a few videos ahead if you have time. NOTE: the videos have slightly outdated format compared to the current version of the course. You want to go through the lecture and change up your code to match the current version. 
2. Do problem bank questions after lectures or pre-readings. You learn best from the course through practice, so make sure to use the comprehensive problem bank after first being exposed to a concept. And if you finished everything already? Nothing wrong with redoing the labs, problem sets, or even the problem bank again.
3. Study consistently, don’t cram everything at once. Pace yourself to progress through content at a comfortable pace. There’s a great deal of research done on retention and spaced repetition that you may want to take a good look at that suggests this. (You can use the UBC Library online search to look up some interesting finds).
4. Come to office hours! Even if you do not need help, often times it keeps you focussed on your tasks and if you ever do get stuck or confused on a topic, you can ask a question right there!
5. Pair programming on problem sets. Now I personally don’t do this, but there is a great deal of support for this style of working as well. Have one person use the mouse or keyboard and collaboratively come up with the answers to the questions. You will find yourselves explaining to each other and bouncing ideas off each other very often with this method.
6. Take a look at the course Piazza, answer each other’s questions and ask your own questions. It can be a good exercise to teach others, as you can end up learning a lot too.


## High Level Summary

The course content all builds upon previous units, so if you find yourself struggling on something, it is best to correct it as soon as possible. Note that the progress of the class in terms of the midterms varies between terms, make sure to consult your syllabus.

### Midterm 1

Units covered:
- 1a: Beginning Student Language
- 1b: How to Design Functions
- 2: How to Design Data
- 3a: How to Design Worlds
- 3b: Compound Data
- 4a: Self-Reference
- 4b: Reference

For midterm 1, you want to focus a lot on “How to Design Data” and “How to Design Functions” units. 

<br>

“How to Design Data” will have a series of rules for creating a data definition and template that will be repeated throughout the course; it would be best to have a lot of these rules memorized through practice. 

<br>

Likewise, “How to Design Functions” is quite important in the course and will introduce a series of steps that you should always follow in the course; remember to keep your purpose down to one line, what makes a good check-expect, and remember that the template of a function will depend on the input data type. This shapes the majority of the content for the course and so a strong base here will pay off much later. 

<br>

Compound Data, Self-Reference, and How To Design Worlds units will have you applying these concepts to various more complex programs or problems. You should be good at solving these problems with enough practice from earlier units and a bit more from these units. Good preparation at this point will save a good amount of time later.

### Midterm 2

Units covered:
- 5a: Naturals
- 5b: Helpers
- 6a: Binary Search Trees
- 6b: Mutual Reference
- 7a: Two One-Of Types
- 7b: Local
- 8: Abstraction
- 9a: Generative Recursion

For midterm 2, make sure you are confident on content from midterm 1 as soon as possible, as a strong base here is essential for easier success afterwards. A lot of focus gets placed on “Mutual Reference” and “Abstraction”. These units tend to give a lot of harder problems that ramp up the difficulty in the course.  You certainly should be confident with each unit covered, but these two units are very important. 

<br>

For “Mutual Reference”, you should be comfortable labeling arrows between data definitions and function definitions as shown in edX and lecture. You should also be prepared to solve rather harder tree-based problems and give suitable templates for them. 

<br>

As for “Abstraction”, this shapes the foundation of a lot of work in programming; you should be prepared to simplify duplicate pieces of code, create more general use functions, and solve some interesting problems using a combination of “built-in abstract functions”.

<br>

Note that the progress of the course on the “Generative Recursion” unit can really differ between years. If it is featured in the midterm, you want to give this unit a fair amount of attention. Practice problems and creative uses of locals are a great help. This is the unit where you really need to “trust” the result of recursion.. If you don’t understand this, ask your Prof or TA. Also don’t forget to write down the termination argument comments.

<br>

For the rest of the units, you should pay attention to the following:
- Natural is a self-referential data type that has a base case of 0. 
- Memorize the helper rules and when they apply (your labs will have a good focus on these). 
- Binary Search Trees are basically a tree with at most two children with a sorting invariant. 
- Two One-Of involves problems with two lists, you want to include the cross-product table in each problem, label all table cells and the relevant cond cases. Simplify the text and code as needed, but make sure the code in the table matches the code in your function.
- For local, you should remember the evaluation rules and the uses of local: to provide encapsulation, to reduce duplicate recursive calls, and to make code more readable.

### Final

Units covered:
- 9b: Search
- 10: Accumulators
- 11: Graphs


For the final, expect a comprehensive evaluation on anything in the course that is listed in the syllabus (sometimes a certain unit may not be covered, so it is best to consult that page). I suggest going back and making sure you are strong starting from the Mutual Recursion from midterm 2.

<br>

Search is often seen as the hardest part in the course. For this unit, you want to do a lot of practice problems and also work on placing down the right templates for a given problem. The templates will nearly always include: a tree template, try-catch, and genrec. Once you've convinced yourself of this, the problems become an applied Generative Recursion problem. Again, do not forget the termination argument comments. The main elements of Geneartive Recursion here depend on the image of the search tree that you end up drawing: your goal is to generate the next level of a tree, and to figure out when it is impossible to generate anymore.

<br>

Accumulators are a tricky unit where less can often be better. You will want to phrase questions in terms of what info you need at any point, to solve a problem. You may need a contextual accumulator, or maybe it is easier to accumulate the result in an accumulator to solve a problem. Don’t forget the accumulator invariant comments.

<br>

Graphs are also seen as one of the hardest units. You want to go back to the basics from Unit 6 and build up from there; graphs are a more general version of a tree. A main difference is that you basically always need to use a “path” or “visited” accumulator to solve these problems, and you have to write a termination argument for the graphs involved as well. You should know when to use “path”, when to use “visited”, and when it is better to use “tail recursion.” It is also a good skill to know when a function is tail recursive. Don’t forget both the accumulator invariants and termination argument.

<br>

When it comes to Tail Recursion, your choices get pretty formulaic: add a worklist accumulator in all cases, turn it into a tandem worklist if you need context info, and use an rsf accumulator if a problem needs to build up an answer.

<br>

I would recommend splitting 30% of the attention on Search, and 60% of the attention on Graphs (spend maybe 10% on accumulators). Graphs are basically an application of Accumulators and Mutual Recursion much like Search is an application of Generative Recursion.


## Unit Notes

### 1a: Beginning Student Language (BSL)

Most of this unit focuses on how to use BSL. Using the Dr Racket Help Desk to search for functions while doing practice problems will be sufficient enough. You want to focus on terminology listed here: https://cs110.students.cs.ubc.ca/reference/language.html to best communicate your ideas to other students and to TAs.

<br>

A main tricky part of this unit comes in the form of evaluation rules. Again, https://cs110.students.cs.ubc.ca/reference/language.html will have an ample summary of the different language features for Beginner Student Language.

### 1b: How to Design Functions

A thorough reference can be found here: https://cs110.students.cs.ubc.ca/reference/design-recipes.html#HtDF.

<br>

Do each step in order (so you don't forget):
1. Signature, purpose stub
2. Examples
3. Template and inventory
4. Function body
5. Test and debug

<br>

Signature:
- From the problem statement, figure out what data types are consumed for each parameter, and what data types are produced. It will follow the format of
- (@signature ConsumedType -> ProducedType)

<br>

Purpose:
- Make a **ONE LINE** statement on what the function does/produces
- Must include **TWO semi colons and a SPACE** to the left of the purpose statement. For example:
`;; produces the sum of a and b`

<br>

Stub
- Make sure that the data type produced by the stub matches the produced type in the function signature.

<br>

Examples:
- make at least 2 examples
- cover different argument/field values
- make sure every line of code in a function is tested
- test points of variation in behavior. 
 - If given a number, check before, at, and after that point. 
 - For example if we make a decision based on if a parameter is the Natural Number 3, you want to check the Naturals: 2, 3, 4
- Ensure that you have 2 long / 2 deep check expects. 
 - This is relevant in the later units, so feel free to ignore for now. 
 - Basically you need to call the Natural Recursion twice, and the Mutual Recursion twice in at least one test case. 

<br>

Template and inventory:
- Copy paste the template for the data type that gives the ‘most’ amount of code (or make the template if the data is ‘primitive’).

<br>

Function body:
- **ONLY** edit the parts of the template **WITH the “(..”** in the beginning of the expression.
- Do not add, edit, or remove ‘cond cases’ unless it is part of the recipe you are working on.



### 2: How to Design Data

A thorough reference is found here (the course does not use intervals anymore): 
https://cs110.students.cs.ubc.ca/reference/design-recipes.html#HtDD

<br>

Note that “interp.” Can be multiple lines long.

<br>

You want to memorize the cases and understand to differentiate between the following (the last two points are for later units):
1. Simple Atomic
2. Enumeration
3. Itemization
4. Compound Data
5. References to other defined type
6. Self reference or mutual reference

<br>

Note the difference between Enumerations and Itemizations.
- Itemizations you will have more than one data type.
- Enumerations will be only a series of specific Strings (as of the current version of the course).
- Templates of both Enumerations and Itemizations match the order presented in the data definition (i.e. if `false` is first in the data definition, make sure `false` is first in the function body).
- The last cond question must be `else` in an Itemization
- The last cond question in an Enumeration must be a question (not `else`) that catches the final Enumeration case.

### 3a: How to Design Worlds
A thorough reference is here: https://cs110.students.cs.ubc.ca/reference/design-recipes.html#HtDW

<br>

This unit mainly focusses on building bigger programs and applying the earlier lessons. You will want to keep track of how to make a domain analysis and when to use each big-bang option. Note that sometimes this unit is omitted from the final exam only, make sure to consult the syllabus.

<br>

A good domain analysis consists of:
1. Three or more pictures at different stages
2. A list of constant information
3. A list of changing information
4. A list of big-bang options

<br>

Big-bang options:
- On-tick: Use if your program changes as time goes on
- To-draw: Use if you need to display something
- On-key: Use if a key press causes a change in the program
- On-mouse: Use if a mouse activity causes a change in the program
- Step-when: Use to stop the program on a condition 

<br>

Most of this unit will be making a series of data definitions and completing a series of functions. It is really applying the previous units. Remember to remove the “wishlist entries” when you are finished. These are the comments with “!!!” in them.

### 3b: Compound Data
Thorough reference can be found here: https://cs110.students.cs.ubc.ca/reference/design-recipes.html#Compound 

<br>

Not much to add on this topic, just be sure to identify how a compound data is perfect for two or more values that make sense to be grouped together. Think if the data would make sense as a row of an Excel spreadsheet.

### 4a: Self-Reference

Reference from here: https://cs110.students.cs.ubc.ca/reference/design-recipes.html#Self-Reference 

<br>

Any self referential data will have a reference to itself in the data definition. This is often in the form of a list. Notice in the following example, how the ListOfString type comment directly has a “ListOfString” inside the itemization:

<br>

```
(@htdd ListOfString)
;; ListOfString is one of:
;;  - empty
;;  - (cons String ListOfString)
;; interp. a list of strings

(define LOS-1 empty)
(define LOS-2 (cons "a" empty))
(define LOS-3 (cons "b" (cons "c" empty)))

(@dd-template-rules one-of            ;2 cases
                    atomic-distinct   ;empty
                    compound          ;(cons String ListOfString)
                    self-ref)         ;(rest los) is ListOfString


(define (fn-for-los los)
  (cond [(empty? los) (...)]                   ;BASE CASE
        [else (... (first los)                 ;String
                   (fn-for-los (rest los)))])) ;NATURAL RECURSION
```

In this unit, you need to decide what to do when your list is empty, and how to combine the first element of a list, with the result of the natural recursion - what does this mean?

#### Trust the natural recursion

When you think back to the evaluation rules, you need to remember that we simplify the operands before evaluating an expression.

```
(+ (+ 4 5) 6)
```

In this example, we need to evaluate `(+ 4 5)` first!

So wherever we see the recursive call `fn-for-los`, in this function body, we will have to assume this is the result of running the function on the rest of the list. 

For example if I want a function that sums a list of numbers
```
(list 1 2 3 4)
```

this means that `fn-for-los` will be the sum of the rest of the list:

```
(fn-for-los (rest los)) = 2 + 3 + 4 = 9
```

and you want to find a way to combine the first of the list, with this sum. 

```
(? 1 9)
```

In this case, the answer would be ‘+’ which gives the function body:

```
(define (fn-for-los los)
  (cond [(empty? los) (...)]                   ;BASE CASE
        [else (+ (first los)                 ;String
                   (fn-for-los (rest los)))])) ;NATURAL RECURSION
```

You want to avoid thinking through the recursive steps, just trust that the recursive call has the result you are looking for on the rest of the list.

### 4b: Reference

Reference: https://cs110.students.cs.ubc.ca/reference/design-recipes.html#Reference

Just note that reference is applied to only data definitions that are defined by you, the programmer. These do not include the data types that are primitive.


### 5a: Naturals

Nothing to add here, just know that Natural can be a self referential data:

```
(@htdd Natural)
;; Natural is one of:
;;  - 0
;;  - (add1 Natural)
;; interp. a natural number
(define N0 0)         ;0
(define N1 (add1 N0)) ;1
(define N2 (add1 N1)) ;2

(@dd-template-rules one-of atomic-distinct compound self-ref)
(define (fn-for-natural n)
  (cond [(zero? n) (...)]
        [else
         (... n   ; n is added because it's often useful                   
              (fn-for-natural (sub1 n)))]))
```


### 5b: Helpers

Remember the following helper rules:
1. Reference: Referring to non-primitive data will require a helper. In this example, `Game` references a non primitive named `Ball`

```
(@htdd Game)
(define-struct game (ball score))
;; Game is (make-game Ball Number) 

;; interp. the current state of a game, with the ball and score

(define GAME-1 (make-game (make-ball 1 5) 2))

(@dd-template-rules compound     ;2 fields
                    ref)

(define (fn-for-game g)
  (... (fn-for-ball (game-ball g))
       (game-score g)))            ;Number
```


2. Function composition: At least one function needs to complete before the other can run; 2 or more distinct operations. For example, we need to sort images before laying them out.

```
;; ListOfImage -> Image
;; arrange images left to right in increasing order of size
(check-expect (arrange-images (list I1 I3 I2))
              (beside I1 I2 I3 BLANK))

(@template-origin fn-composition)

(define (arrange-images loi)
  (layout-images (sort-images loi)))
```
(reference: https://cs110.students.cs.ubc.ca/reference/design-recipes.html#FuncComp)

3. Operating on arbitrary-sized data: Operating on a list arbitrarily far or do something to list as a whole i.e. taking an average of a list or inserting an image into a list:

```
(define (sort-images loi)
  (cond[(empty? loi) empty]
       [else
        (insert-img (first loi)
        (sort-images (rest loi)))]))
```

4. Knowledge domain shift: Two or more different tasks are occurring and the other helper rules still do not apply. In this example it is when we are calling the function ‘larger’

```
(define (insert img loi)
  (cond [(empty? loi)(cons img empty)]
        [else 
         (if (larger? img (first loi))
             (cons (first loi) NR)
             (cons img loi)]))


```

### 6a: Binary Search Trees

Just solve problems using this data definition and template: 
```
(define-struct node (key val l r))
;; A BST (Binary Search Tree) is one of:
;;  - false
;;  - (make-node Integer String BST BST)
;; interp. false means no BST, or empty BST
;;         key is the node key
;;         val is the node val
;;         l and r are left and right subtrees
;; INVARIANT: for a given node:
;;     key is > all keys in its l(eft)  child
;;     key is < all keys in its r(ight) child
;;     the same key never appears twice in the tree
; .
;<snip>
(define (fn-for-bst t)
  (cond [(false? t) (...)]
        [else
         (... (node-key t)    ;Integer
              (node-val t)    ;String
              (fn-for-bst (node-l t))
              (fn-for-bst (node-r t)))]))

```

What makes these BSTs special from other trees covered in the course, is how we have the sorted *INVARIANT*.


### 6b: Mutual Reference


We have Arbitrary Arity trees, which are a tree that has an arbitrary width (number of children) and an arbitrary depth. These trees will often support Mutual Reference.

<br>

Be able to figure out Reference, Mutual Reference, and Self Reference between data definitions and also between templates.


```
;; Type is one of:
;; - “City”
;; - “State”
;; - “Province”
;; - “Country”
;; - “Continent”

(define-struct region (name type subs))
;; Region is (make-region String Type ListOfRegion)
;; a region with its name, type, and the region inside it

;; ListOfRegion is one of:
;; - empty
;; - (cons Region ListOfRegion)
;; a list of regions
```


Self Reference is when in a data definition, we have a reference to the data type itself. We have self reference between ListOfRegion and itself.

<br>

Mutual Reference is when in a data definition, we can trace reference arrows between multiple data types that eventually end up back at this data definition. We have mutual reference through Region and ListOfRegion. 

<br>

Reference is when we refer to a non primitive data type in a data definition. In these cases where we need to identify if something is reference, self reference, or mutual reference, choose the label of ‘reference’ for anything not covered by the above cases.

<br>

In terms of function calls, remember that Reference from the data corresponds to a “Natural Helper,” Self Reference corresponds to “Natural Recursion”, and Mutual Reference corresponds to “Natural Mutual Recursion”.

<br>

This code should match the above data definition:

```
define (fn-for-type t)
	(cond [(string=? T “City”) (...)]
		[(string=? T “State”) (...)]
		[(string=? T “Province”) (...)]
		[(string=? T “Country”) (...)]
		[(string=? T “Continent”) (...)]))

(define (fn-for-region r)
	(... (region-name r)
		(fn-for-type (region-type r))
		(fn-for-lor (regions-subs r))))

(define (fn-for-lor lor)
	(cond [(empty? lor) (...)]
		[else
(...  (fn-for-region (first lor))
(fn-for-lor (rest lor)))]))

```

In order to solve problems using Mutual Recursion, I suggest looking at each function separately.

<br>

In the example above, I would ask:
1. “What do I do if I encounter a single type?” - the answer should be reflected in `fn-for-type`.
2. “How do I combine the results of a single region and the children of that region?” - the answer would be reflected in `fn-for-region`
3. “How do I combine the result of multiple children of the same region? “ the answer is reflected in `fn-for-lor`.

<br>

A good example of understanding this would be to render an image of this tree.

#### Backtracking Search

Reference: https://cs110.students.cs.ubc.ca/reference/design-recipes.html#Backtrack
Not much to add to here, but here is a quick summary:

<br>

Typically if a question asks you to find if something exists in a tree, you will most likely use the `try-catch` template. Immediately remember to add the `or false` at the end of the signature.

<br>

The main idea is that you stop once the answer has been found, or signal failure if you fail to find a result.

In these cases, blending the try-catch template into your function body will be as follows:

```
(@template-origin X)

(define (fn-for-x x)
  (if (have-we-found-result? x)  ;success?
      (produce-result x)         ;produce correct value
      (fn-for-lox (x-subs x))))  ;search in the subs

(@template-origin try-catch ListOfX)

(define (fn-for-lox lox)
  (cond [(empty? lox) false]
        [else
          (if (not (false? (fn-for-x (first lox))));is first a success?
              (fn-for-x (first lox)) ;if success, produce
(fn-for-lox (rest lox)))])) ;try rest
```


### 7a: Two One-Of Types

A good reference: https://cs110.students.cs.ubc.ca/reference/design-recipes.html#2One-of

<br>

This recipe is for when you are operating on two parameters with `one-of` type comments in their data definitions. You want to make two axes for each function parameter, and label it with the cases from their type comments. You table and code have to be labelled **and** the table must have the exact code expressions used in your function body.

<br>

Take an example of:

```
;; ListOfNumber is one-of:
;; - empty
;; - (cons Number ListOfNumber)


(@htdf merge)
(@signature ListOfNumber ListOfNumber -> ListOfNumber)
;; produce sorted lon by merging two sorted lists of numbers

(define (merge l1 l2) empty) ;stub
```


This would give a cross section of `l1`, `l2` and their type comments as the column/row labels:

```
#| 
   l2 ->                    empty        (cons Number ListOfNumber)
   l1       
    |
    v 
  empty                      [1]        		[2]
 
(cons Number ListOfNumber)   [3]        		[4]
|# 

```

When testing, you need to test all of these 4 cells of the table at least once, even if you simplify the cases. In addition, you need to make sure the code and table are labelled and match correctly. Note that the table cells have only the cond answers. You want to use the types in the axes to ask the right cond question to grab that cell.

<br>

A correct answer:

```
<...>
#|
   l2 ->                    empty        (cons Number ListOfNumber)
   l1       
    |
    v 
  empty                      l2 [1]        l2 [1]
 
(cons Number ListOfNumber)   l1 [2]      | (if (<= (first l1)   
(first l2))  
                                          (cons (first l1)
                                           (merge (rest l1) l2))
                                         (cons (first l2)
                                         (merge l1 (rest l2))))[3]
|# 
<...>
(@template-origin 2-one-of)
(define (merge l1 l2)
  (cond [(empty? l1) l2]  ;[1]                 
        [(empty? l2) l1]  ;[2]                  
        [else             ;[3]                   
         (if (<= (first l1) (first l2))
             (cons (first l1)
                   (merge (rest l1) l2))
             (cons (first l2)
                   (merge l1 (rest l2))))]))

```

Notice how asking if `l1` is `empty` can get the entire first row of the table (originally cells 1 and 2). This is an example of making cond questions based on the table axes. Finally, notice how the code is labelled and the the function body matches the cases in the table.

### 7b: Local

Local has three uses in the course:
1. Encapsulation
 - wrap functions with the same purpose into a local
2. Avoiding repeated identical recursive calls
 - recursive calls can be expensive in terms of speed and space, so avoiding them would be great
 - use local to save the result of the recursive call to a constant. For example:
 ```
 define (fn-for-lox lox)
            (cond [(empty? lox) false]
                  [else
                   (local [(define try (fn-for-x (first lox)))]
                     (if (not (false? try))                    
                         try                                   
                         (fn-for-lox (rest lox))))
```
3. Readability
 - `(+ (* w h l) 30)` vs `(+ volume 30)` is a good example of making things more readable by using local

<br>

Make sure that you are aware of the evaluation rules regarding local:
(search for local in the webpage: https://cs110.students.cs.ubc.ca/reference/language.html)

<br>

You can often be tested on how many definitions are lifted when calling some complex or even recursive local function. Not much advice I can give here aside from practice on past exams.

<br>

Finally, be aware of what a closure is:

A closure is:
- a locally defined function (using lambda or local)
 - in which the body uses a name (function or parameter) that is not defined in the local function itself, AND
also not defined at top-level
- in other words it uses a name that is defined in the function or functions enclosing the local

<br>

In summary, check if a function can exist outside a local if you brought it to top-level without modifying it. There are some good questions on identifying closures in the past exam bank as well. Again with the evaluation stepping, the best way to get good at this is practice on past exams.


### 8: Abstraction

The main point of this unit is to use identify and address duplicate code, make general `fold` functions, and to apply the built-in abstract functions that are already present within the language.

The built-in abstract functions are as follows:
- `(define (build-list n f) ...)`
 - create a list of items from applying the function `f` onto each of the numbers `0... n-1`
- `(define (filter p lox) ...)`
 - remove elements from a list that do not satisfy `p`
 - `p` should be a function that produces `true` or `false`
 - i.e. remove all negative numbers
- `(define (map f lox) ...)`
 - apply the function `f` to each element in a list
 - i.e. multiply each number in a list by 2
- `(define (andmap p lox) ...)`
 - check if all elements in a list satisfy `p`
- `(define (ormap p lox) ...)`
 - check if at least one element in a list satisfies `p`
- `(define (foldr f base lox) ...)`
 - use this to apply an operation onto an entire list; this is an abstract version of the list template
 - this (and foldl) are also the only abstract functions that allow you to change the result type to something that is **not** a list or boolean
 ```
 (define (foldr f b lox)
 (cond [(empty? lox) b]
  [else
 	(f (first lox)
 	(foldr (rest lox)))]))
 ```
- `(define (foldl f base lox) ...)`
 - this is a tail recursive version of foldr, otherwise it is basically the same functionality.
 - it can lay an image out in reverse order compared to foldr (try it out!)

<br>

Be able to combine these functions with each other to solve hard problems. Good examples are in the exam bank. In general, I try to use the purpose of the functions and knowing the data types I can produce with them, to solve the issues. For example, if I know I need to produce a number at the end, then I will definitely use foldr or foldl as the final function to solve that problem. Likewise, if I need to match a criteria, I will probably use filter at some point.

<br>

Next, make sure to understand how to abstract from examples. This is an important skill in programming. Take two or more pieces of code that look very similar. You want to parameterize **only** the differences between them. Seriously, be as lazy as possible.

<br>

Sample code:

```
(define (contains-ubc? los)
  (cond [(empty? los) false]
        [else
         (if (string=? (first los) "UBC")
             true
             (contains-ubc? (rest los)))]))


(define (contains-mcgill? los)
  (cond [(empty? los) false]
        [else
         (if (string=? (first los) "McGill")
             true
             (contains-mcgill? (rest los)))]))
```

Notice that there is only really one difference here, so we can make a more general function here with a parameter `s`:

```
(define (contains? s los)
  (cond [(empty? los) false]
        [else
         (if (string=? (first los) s)
             true
             (contains? s (rest los)))]))
```

<br>

Finally, a skill you should know is working with abstract fold functions. It is really just a template with the dots `...` filled in with a parameter. Note that the parameter order should be: combinations first, base cases next, and the data last. I find that the hardest things about these problems can be parsing the signature. Take the following example of a template turned into a fold function:

```
(define (fn-for-course c0)
  (local [(define (fn-for-course c)
            (... (course-number c)
                 (course-credits c)
                 (fn-for-loc (course-dependents c))))

          (define (fn-for-loc loc)
            (cond [(empty? loc) (...)]
                  [else
                   (... (fn-for-course (first loc))
                        (fn-for-loc (rest loc)))]))]
    (fn-for-course c0)))

(define (fold-course  c1 c2 b c0)
  (local [(define (fn-for-course c)
            (c1 (course-number c)
                 (course-credits c)
                 (fn-for-loc (course-dependents c))))

          (define (fn-for-loc loc)
            (cond [(empty? loc) b]
                  [else
                   (c2 (fn-for-course (first loc))
                        (fn-for-loc (rest loc)))]))]
    (fn-for-course c0)))

```

When parsing the signature, I recommend starting with making bracket pairings if I know one argument is a function. Before guessing any types, I also like to also place down `_` where I would normally write a type name. So from the example, I would first put down:

```
(@signature ( _ _ -> _) (_ _ -> _) _ _ -> _)
```

After this, you really want to approach with piecing together each Type in the spaces. I find it easier to reason based off pairing which parameter types should be the same.

From glancing at the `fold-course`, you can see that `b` and `c2` should both produce the same type, because if we hit the base case, we will produce b, otherwise we will prodice the result of `c2`.

Meanwhile, you can immediately see that the trampoline call is `(fn-for-course c0)`, which means that whatever type `fn-for-course` produces will be what our `fold-course` produces.

You can leave comments when parsing the signature to check over, which I would highly recommend. Here is an example of my work when parsing this signature:

```
;(@signature ( _ _ -> X) (_ _ -> Y) _ Course -> _)
;(@signature (Natural Natural Y -> X)(_ _ -> _) _ Course -> _)
;(@signature (Natural Natural Y -> X)(X Y -> Y) _ Course -> _)
;(@signature (Natural Natural Y -> X)(X Y -> Y) Y Course -> _)
(@signature (Natural Natural Y -> X)(X Y -> Y) Y Course -> X)
```

### 9a: Generative Recursion

Reference: https://cs110.students.cs.ubc.ca/reference/design-recipes.html#GenRec

<br>

By definition from the htdp book, generative recursion is where

>  An algorithm tends to rearrange a problem into a set of several problems, solve those, and combine their solutions into one overall solution.

(Source: https://htdp.org/2018-01-06/Book/part_five.html )

This is different from structural recursion where we can depend on the structure of the data (i.e. the type comments) to solve the problem with a trusted template that uses `(first lox)` or `(rest lox)` that we know will work; these questions can require some unique insight to get working.

<br>

Mainly in the class you will be finding different ways to apply/blend this template:
```
(@template-origin genrec)

(define (genrec-fn d)
  ;; trivial: condition to be triggered
  ;; reduction step: how we approach base per recursion
  ;; argument: reason why we will eventually hit base
  (cond [(trivial? d) (trivial-answer d)]
        [else
         (... d 
              (genrec-fn (next-problem d)))]))
```




Make sure to write out the termination argument to ensure that you know this function will terminate, and to also convince any readers that the function will not infinitely recurse. Most practices for this unit will come out of fractals, which are images with recursive elements about them. For example, in fractals you will often you will have one or more recursive calls, and the main issues involve the following questions:

1. By what factor will the image size decrease with each recursion?
2. What should be the base case?
3. What does it mean to trust the result of the recursion?
4. How do I arrange the recursive calls to create this image?

Note a good use for local in this case: if you have multiple of the same recursive calls, you can save one recursive call to a constant in the local and reuse it! Look at this bit of code and how we reuse the `leaf` constant

```
(define (draw-leaf n)
  ;; trivial: size is less than TRIVIAL-SIZE
  ;; reduction step: reduce size by STEP and
  ;;                 recurse on that to build leaves
  ;; argument: reduction step reduces size of leaves
  ;;           so eventually it will be
  ;;           less than TRIVIAL-SIZE
  (cond[(<= n TRIVIAL-SIZE) (circle n "solid" "blue")]
       [else
        (local [(define center (circle n "solid" "blue"))
                (define leaf (draw-leaf (* n STEP)))]
          (above leaf
                 (beside
                  (rotate 90 leaf)
                  center (rotate -90 leaf))))]))

```

Again, the exam bank has some very good examples of this, which can be quite challenging. However, if you can convince yourself to trust the result of recursion, these questions become much less complicated. Search is also a good application of genrec which you can read below.

### 9b: Search

Reference for template blending: https://cs110.students.cs.ubc.ca/reference/design-recipes.html#TempBlend

<br>

This unit is often seen as the most challenging in the course, so a good base in the content before will prove its worth in spades.

<br>

Search has 3 main parts: a tree structure, generative recursion, and backtracking. You use generative recursion to create a tree of possibilities, and terminate the program as soon as you find a solution using backtracking. For example, try to solve a sudoku board by filling in all possible combinations of numbers, or try to navigate a 2d maze by trying all possible movement combinations.

<br>

In summary, you are using a program to guess all the next possible choices, and see if we can solve the problem from that guess.

<br>

My recommendations for solving this would incude:
1. Draw a picture of the search state. This should be the root node of your tree.
2. Pick something to vary or change in hopes of getting to a solution. This should form the next layer in your tree. In other words, these are children nodes of the initial state.
 - In the case of sudoku, it would be the number we insert into a single empty cell
 - In the case of a maze, it would be the direction we move in
3. Pick the tree template from this diagram and **blend the templates**
4. Figure out the generative recursion details using the tree
 - how do you generate this next layer of the tree
 - when is it impossible to generate more layers of the tree
 - when do you solve your problem
 - figure out if there any impossible or invalid states to filter out

<br>

Really the most variation comes in step 4 in terms of the code. Most of the tree code remains consistent thorughout most search problems. Therefore, I suggest becoming confident in the template blending and previous unit. Most code examples that are the same (this is for an arb-arity tree):

```
(define (solve bd)
  ;; trivial: fill this in
  ;; reduction step: fill this in
  ;; argument: fill this in
  (local [(define (solve--bd bd)
            (if (solved? bd)
                bd
                (solve--lobd (generate-level bd))))

          (define (solve--lobd lobd)
            (cond [(empty? lobd) false]
                  [else
                   (local [(define try (solve--bd (first lobd)))]
                        (if (not (false? try))
                            try
                          (solve--lobd (rest lobd))))
					;helpers and other functions
					]))]

    (solve--bd bd)))

```

<br>

I find that the lectures, lab, and problem set were sufficient practice for the topic. When you convince yourself that most of this code would be the same (minus Generative Recursion), and get confident with template blending, the scariness of Search tends to get closer to the previous unit.

### 10: Accumulators

Reference: https://cs110.students.cs.ubc.ca/reference/design-recipes.html#Accumulators

<br>

The unit brings a much needed break from some very difficult search problems, to more smaller problems. Consider that we cannot view info that we looked at in the past in BSL and ISL. For example when summing a number, we only really have access to the info in the `(first lon)` at any point.

```
(define (sum lon)
       (cond[(empty? lon) 0]
	        [else 
			(+ (first lon) (sum (rest lon)))]))
```
If we need to do something like check if the previous number was an odd number, it would be impossible currently. So therefore we need accumulators in cases where we need to save such contextual info.

<br>

You have three uses for accumulators:
- Context preserving from previous recursive calls
- Keeping track of a result so far
 - this is mostly relevant for tail recursion, but it can be useful to solve questions that build as you recurse
 - in some cases this can make questions easier to solve
- A list of work we still need to do
 - this is relevant for graphs

<br>

Some things to note about this unit:
1. Always write down your accumulator comment and invariant
2. Be aware of the terminology used in class: `initialize`, `preserve`, and `exploit` gives an easy way to remember what to do on these problems when stuck, and it makes it easier to express which steps you are stuck on.
3. You will always use `local` in these questions.

### 11: Graphs

This unit comes at the end of the course where you are often quite burnt out, so you will want to rely a lot on the previous units.

<br>

In a rather simplistic explanation, graphs are more general versions of trees; you can have `cycles` or `joins`. `Cycles` are where you can follow the edges (the arrows) of a tree to start and end at the same node. `Joins` are where you can have multiple ways to visit the same node. Luckily, unit 6 focussed on trees, which makes our work much simpler; we just need to add the code to take care of cycles and joins to what we used in unit 6.

<br>

If you just want to terminate and find an answer, use a `path` accumulator. You will just append a unique member of the current node (or the entire node itself if not possible) onto an accumulator and check if we have that in the list before.  We will use an example of a tree of rooms:

```
;; TERMINATION ARGUMENT
;; base case: list of rooms is empty
;; reduction step: add every possible room to the path
;; argument: new room names added to path. Old rooms
;; will not be visited again due to member, exhausting all possible nodes
(define (fn-for-house r0)
  ;; path is (listof String); context preserving acc, names of rooms
  (local [(define (fn-for-room r path) 
            (if (member (room-name r) path)
                (... path)
                (fn-for-lor (room-exits r) 
                            (cons (room-name r) path)))) 
          (define (fn-for-lor lor path)
            (cond [(empty? lor) (...)]
                  [else
                   (... (fn-for-room (lookup-room (first lor)) path)
                        (fn-for-lor (rest lor) path))]))]
    (fn-for-room r0 empty)))
```

And this is really the minimum requirement that you need to add to the code from unit 6 (note the `lookup` function is always added somewhere in your code as well, this is more of a technical thing involving the graph data structure that isn't important to the course learning).

This code will catch any `cycles` so you can be assured that you won't infinitely recurse. In short, it records the traversal of our function using structural recursion. Now you can just solve like in unit 6. However, **remember to add a termination argument** as `lookup-room` is a generative recursion element added to the code.

<br>

#### Tail Recursion

Most of the difficulty in this unit tends to come from the tail recursive implementation. First of all, you should use tail recursion if a graph you are working on is very large (this distinction is made clear in any problems if large). This is because you will save a lot more space using the technique; structural recursion uses a lot of space and with a large graph, this can slow down a program a LOT. Secondly, you will always have a worklist (or tandem worklist).


This is where you need to choose between path and visited accumulators, and where you need to understand worklists.

`visited` accumulators will stop `cycles` and `joins`, which can help speed up your program a fair bit. You want to use this on large graphs.

**However**, if you need to consider multiple paths (i.e. pick the shortest one), you should not use visited. This is because you will only consider one path through a given node, which means you can lose some possibly better paths all because they use the same node.

Note that a todo list should be a list of places to visit next. We lose track of the order of traversal when we use tail recursion. So when you are at any certain node, make sure to save the mutually recursive data members to an accumulator. This will be more clear in a code example.

Taking the previous example, if we convert the code to be tail recursive and use visited, we get:

```
;; TERMINATION ARGUMENT
;; base case: list of rooms is empty
;; reduction step: add every possible room to visited
;; argument: new room names added to visited. Old rooms
;; will not be added to todo, exhausting all possible todo nodes
(define (fn-for-house r0)
  ;; todo is (listof String); a worklist accumulator of room names
  ;; visited is (listof String); ctxt preserving acc, names of rooms
  ;;                             already visited
  (local [(define (fn-for-room r todo visited) 
            (if (member (room-name r) visited)
                (fn-for-lor todo visited)
                (fn-for-lor (append (room-exits r) todo)
                            (cons (room-name r) visited)))) 

          (define (fn-for-lor todo visited)
            (cond [(empty? todo) (...)]
                  [else
                   (fn-for-room (lookup-room (first todo))
                                (rest todo)
                                visited)]))]
    (fn-for-room r0 empty empty))) 
```

Notice how we append the room exits to the `todo` list and how the `visited` code looks like it is used in the same way as the `path` code before. 

<br>

#### Tandem Worklists

Finally the last topic involves tandem worklists, which is a basically just adding a second list to match the `todo` from earlier. 

Suppose you add a context preserving accumulator to the above code; this context changes as we visit new nodes, however the order that we visit nodes with tail recursion changes. So to fix this, we add a copy of the context info, for each addition to the todo list.

```
(define (fn-for-house r0)
  ;; todo is (listof String); a worklist accumulator of room names
  ;; visited is (listof String); ctxt preserving acc, names of rooms
  ;;                             already visited
  ;; c is String; parent room name
  (local [(define (fn-for-room r t-wl visited c-wl c) 
            (if (member (room-name r) visited)
                (fn-for-lor todo visited c-wl)
                (... c (fn-for-lor (append (room-exits r) todo)
                            (cons (room-name r) visited)
							(append (map (λ (e) (room-name r)) (room-exits r)) c-wl)))) 

          (define (fn-for-lor t-wl visited c-wl)
            (cond [(empty? t-wl) (...)]
                  [else
                   (fn-for-room (lookup-room (first t-wl))
                                (rest t-wl)
                                visited
								c-wl
								(first c-wl))]))]
    (fn-for-room r0 empty empty empty ""))) 
```

Notice that the significant change is a map which copies a room name for each new exit we are adding to the todo. This info is added onto another worklist.



## Study Schedule

There is no science to really back up this schedule, but I did end up using this when taking the course in the summer section, but I am spreading it acrosss a few days. This section is for final exam prep, but ideally you should be doing some practice between classes. Try to map out some of the harder problem set and lab questions that you had difficulty with before starting to actually study. Also when studying, I suggest taking a 5 minute break every 20 minutes, unless you are doing a practice exam. Doing this all in one sitting can also be quite draining.
<br>
Feel free to do what you find helpful; this is just my personal schedule during the exam season without classes.

|Schedule| Time Per Day|
|---|---|
|Problem Bank| 0.5 hr|
|Labs| 0.5 hr|
|Problem Sets| 1 hr|
|Exams Bank| 2 hrs|

### Problem Bank

I would suggest working on the hard difficulty problems, and focussing on units 6 and higher. Ideally you will have seen most of these questions before, so I don't recommend focussing much on the easy questions.

I would try to get an even spread across Graphs, Search, Accumulators, Mutual Ref, Two-one-of, Local, and Abstraction over the time you spend studying.

### Labs

I found it useful to work on the labs again, but only really the harder questions. I would pick an assortment of 3 lab problems and give myself the data defininitions in an attempt to solve it again. Again, I really only picked the ones I was not very confident in.

The graph lab, search lab, accumulator lab, and helper lab had some questions that gave me a fair bit of challenge when doing the course for example.

### Problem Sets

In terms of problem sets, I find I had a lot more challenging topics pop up so I preferred to spend more time redoing them. I would do one problem set and give myself about an hour to finish it for the day. However for the ones including defining data constants, I would leave those in the file to focus on the problems.

I wouldn't focus too heavily on a question if you can solve it quickly, as again, you have already seen these problems at this point. Focus on what you had trouble with and try to understand the process to derive an answer,

### Practice Exams

Starting from the most recent year, I definitely focussed on Past Final Exams. I would give myself 2 hours instead of the usual 2.5, to get as far as possible in an exam. My goal was usually to complete the entire exam, but of course it isn't always possible to in that time frame. I found that pressuring myself during practice would prep me to perform faster when doing the actual exam.

If you do not wish to do that, taking a totally relaxed approach is fine too. Just keep in mind that simulating a test environment and setting can be helpful. I would do at least one 2.5 hour practicce session before the exam day.







